<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linear Programming Explorer</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-slate-50 text-slate-900 h-screen overflow-hidden">
    <div id="root" class="h-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useLayoutEffect, useRef, useMemo, useCallback, memo } = React;

        // --- Utility Functions ---

        const getRandomColor = () => {
            const colors = [
                '#ef4444', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899', '#06b6d4'
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        };

        // --- Grade 11 Real Life Scenarios ---
        const SCENARIOS = [
            {
                id: 'bakesale',
                title: "The School Bake Sale",
                icon: "apple",
                type: "Maximize Profit",
                intro: "You are organizing a bake sale to raise money for prom. You plan to sell Cupcakes (x) and Cookies (y). Your goal is to make the most money possible, but you are limited by how much flour you have and how much time you have to bake before the event starts.",
                modelDescription: "Optimization Goal: Find the combination of Cupcakes and Cookies that gives the highest total profit.",
                constraints: [
                    { title: "Flour Constraint", desc: "You have 40 cups of flour. A batch of Cupcakes needs 4 cups, and a batch of Cookies needs 2 cups.", color: "blue" },
                    { title: "Time Constraint", desc: "You have 12 hours max. Cupcakes take 1 hour per batch, Cookies take 1 hour per batch.", color: "orange" },
                    { title: "Reality Constraint", desc: "You can't bake negative amounts.", color: "slate" }
                ],
                goal: "Profit Function: $20 per Cupcake batch + $15 per Cookie batch",
                objective: { a: 20, b: 15, startVal: 0 },
                equations: [
                    { a: 4, b: 2, c: 40, sign: '≤' },
                    { a: 1, b: 1, c: 12, sign: '≤' },
                    { a: 1, b: 0, c: 0, sign: '≥' },
                    { a: 0, b: 1, c: 0, sign: '≥' }
                ]
            },
            {
                id: 'study',
                title: "Exam Study Schedule",
                icon: "book-open",
                type: "Maximize Grades",
                intro: "Finals are coming up! You need to split your study time between Math (x) and Science (y). You want to maximize your total score points, but you have limited hours in the day and strict minimum requirements from your parents.",
                modelDescription: "Optimization Goal: Allocate your study hours to get the highest possible combined score, assuming studying effectively yields points.",
                constraints: [
                    { title: "Total Time", desc: "You only have 10 hours available to study this weekend.", color: "indigo" },
                    { title: "Math Requirement", desc: "You are struggling in Math, so you must study at least 2 hours.", color: "rose" },
                    { title: "Balance Constraint", desc: "You shouldn't study Science more than twice as much as Math.", color: "emerald" },
                    { title: "Basic Logic", desc: "Time cannot be negative.", color: "slate" }
                ],
                goal: "Score Function: 5 points/hr for Math + 4 points/hr for Science",
                objective: { a: 5, b: 4, startVal: 0 },
                equations: [
                    { a: 1, b: 1, c: 10, sign: '≤' },
                    { a: 1, b: 0, c: 2, sign: '≥' },
                    { a: -2, b: 1, c: 0, sign: '≤' }, // y - 2x <= 0  -> y <= 2x
                    { a: 1, b: 0, c: 0, sign: '≥' },
                    { a: 0, b: 1, c: 0, sign: '≥' }
                ]
            },
            {
                id: 'summerjob',
                title: "Summer Jobs",
                icon: "dollar-sign",
                type: "Maximize Income",
                intro: "You have two summer job offers. Job A (Landscaping) pays well but is hard physical work. Job B (Library Assistant) pays less but is easy. You want to earn as much money as possible for a new car.",
                modelDescription: "Optimization Goal: Determine how many hours to work at each job to maximize your total summer income.",
                constraints: [
                    { title: "Energy Limit", desc: "Landscaping (x) is tiring. You can't handle more than 10 hours a week.", color: "amber" },
                    { title: "Work Week Limit", desc: "You are allowed to work a maximum of 20 hours total per week.", color: "cyan" },
                    { title: "Minimum Income", desc: "You need to work enough to pay for gas, so you need at least 5 hours at the library.", color: "blue" },
                    { title: "Reality", desc: "Hours cannot be negative.", color: "slate" }
                ],
                goal: "Income Function: $25/hr Landscaping + $15/hr Library",
                objective: { a: 25, b: 15, startVal: 0 },
                equations: [
                    { a: 1, b: 0, c: 10, sign: '≤' },
                    { a: 1, b: 1, c: 20, sign: '≤' },
                    { a: 0, b: 1, c: 5, sign: '≥' },
                    { a: 1, b: 0, c: 0, sign: '≥' },
                    { a: 0, b: 1, c: 0, sign: '≥' }
                ]
            }
        ];

        // --- Math Logic for Geometry ---

        const checkInequality = (x, y, ineq) => {
            const val = ineq.a * x + ineq.b * y;
            const tolerance = 1e-10;
            switch (ineq.sign) {
                case '≤': return val <= ineq.c + tolerance;
                case '≥': return val >= ineq.c - tolerance;
                case '<': return val < ineq.c - tolerance;
                case '>': return val > ineq.c + tolerance;
                default: return false;
            }
        };

        const getIntersections = (A, B, C, xMin, xMax, yMin, yMax) => {
            const points = [];
            const TOLERANCE = 1e-10;

            const addIfValid = (x, y) => {
                const xValid = x >= xMin - TOLERANCE && x <= xMax + TOLERANCE;
                const yValid = y >= yMin - TOLERANCE && y <= yMax + TOLERANCE;
                if (xValid && yValid) {
                    points.push({ x, y });
                }
            };

            if (Math.abs(B) > TOLERANCE) {
                addIfValid(xMin, (C - A * xMin) / B);
                addIfValid(xMax, (C - A * xMax) / B);
            }

            if (Math.abs(A) > TOLERANCE) {
                addIfValid((C - B * yMin) / A, yMin);
                addIfValid((C - B * yMax) / A, yMax);
            }

            return points;
        };

        // --- Components ---

        const ICONS = {
            'plus': <><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></>,
            'trash-2': <><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></>,
            'check': <polyline points="20 6 9 17 4 12"></polyline>,
            'eye': <><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></>,
            'eye-off': <><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line></>,
            'zoom-in': <><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></>,
            'zoom-out': <><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line></>,
            'refresh-ccw': <><polyline points="1 4 1 10 7 10"></polyline><polyline points="23 20 23 14 17 14"></polyline><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path></>,
            'drafting-compass': <><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></>,
            'book-open': <><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></>,
            'x': <><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></>,
            'dollar-sign': <><line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path></>,
            'hammer': <><path d="M15 12l-8.5 8.5c-.83.83-2.17.83-3 0 0 0 0 0 0 0a2.12 2.12 0 0 1 0-3L12 9"></path><path d="M17.64 15L22 10.64"></path><path d="M20.91 11.7l-1.25-1.25c-.6-.6-.93-1.4-.93-2.25V7.86c0-.55-.45-1-1-1H14.14c-.85 0-1.65-.33-2.25-.93L10.64 4.64"></path></>,
            'apple': <><path d="M12 20.94c1.5 0 2.75 1.06 4 1.06 3 0 6-8 6-12.22A4.91 4.91 0 0 0 17 5c-2.22 0-4 1.44-5 2-1-.56-2.78-2-5-2a4.9 4.9 0 0 0-5 4.78C2 14 5 22 8 22c1.25 0 2.5-1.06 4-1.06Z"></path><path d="M10 2c1 .5 2 2 2 5"></path></>,
            'save': <><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></>,
            'play': <polygon points="5 3 19 12 5 21 5 3"></polygon>,
            'sliders': <><line x1="4" y1="21" x2="4" y2="14"></line><line x1="4" y1="10" x2="4" y2="3"></line><line x1="12" y1="21" x2="12" y2="12"></line><line x1="12" y1="8" x2="12" y2="3"></line><line x1="20" y1="21" x2="20" y2="16"></line><line x1="20" y1="12" x2="20" y2="3"></line><line x1="1" y1="14" x2="7" y2="14"></line><line x1="9" y1="8" x2="15" y2="8"></line><line x1="17" y1="16" x2="23" y2="16"></line></>
        };

        const Icon = memo(({ name, size = 16, className }) => {
            const content = ICONS[name] || null;
            return (
                <svg 
                    xmlns="http://www.w3.org/2000/svg" 
                    width={size} 
                    height={size} 
                    viewBox="0 0 24 24" 
                    fill="none" 
                    stroke="currentColor" 
                    strokeWidth="2" 
                    strokeLinecap="round" 
                    strokeLinejoin="round" 
                    className={className}
                >
                    {content}
                </svg>
            );
        });

        const ScenarioModal = memo(({ scenario, onClose, onLoadEquations, onSave }) => {
            if (!scenario) return null;

            const getColorClasses = (color) => {
                const map = {
                    blue: "bg-blue-50 border-blue-200 text-blue-800",
                    orange: "bg-orange-50 border-orange-200 text-orange-800",
                    slate: "bg-slate-50 border-slate-200 text-slate-600",
                    emerald: "bg-emerald-50 border-emerald-200 text-emerald-800",
                    amber: "bg-amber-50 border-amber-200 text-amber-800",
                    indigo: "bg-indigo-50 border-indigo-200 text-indigo-800",
                    rose: "bg-rose-50 border-rose-200 text-rose-800",
                    cyan: "bg-cyan-50 border-cyan-200 text-cyan-800",
                };
                return map[color] || map.blue;
            };

            return (
                <div className="absolute inset-0 z-50 flex items-center justify-center bg-slate-900/60 backdrop-blur-sm p-4 animate-in fade-in duration-200">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-lg w-full overflow-hidden border border-slate-200">
                        {/* Header */}
                        <div className="bg-white border-b border-slate-100 p-6 flex justify-between items-start">
                            <div className="flex gap-4">
                                <div className="p-3 bg-blue-100 text-blue-600 rounded-xl shadow-sm">
                                    <Icon name={scenario.icon || 'book-open'} size={24} />
                                </div>
                                <div>
                                    <span className="text-xs font-bold text-blue-600 uppercase tracking-wider">{scenario.type || 'Scenario'}</span>
                                    <h2 className="text-2xl font-bold text-slate-800 mt-1">{scenario.title}</h2>
                                </div>
                            </div>
                            <button onClick={onClose} className="text-slate-400 hover:text-slate-600 p-2 hover:bg-slate-100 rounded-lg transition-colors">
                                <Icon name="x" size={20} />
                            </button>
                        </div>
                        
                        {/* Body */}
                        <div className="p-6 overflow-y-auto max-h-[60vh]">
                            <p className="text-slate-600 text-lg mb-4 leading-relaxed">
                                {scenario.intro}
                            </p>

                            {/* The Math Model Explanation */}
                            <div className="mb-6 p-3 bg-indigo-50 rounded-lg border border-indigo-100">
                                <h4 className="text-xs font-bold text-indigo-800 uppercase mb-1">The Math Model</h4>
                                <p className="text-sm text-indigo-900 font-medium">
                                    {scenario.modelDescription}
                                </p>
                            </div>
                            
                            <div className="space-y-3">
                                {scenario.constraints.map((item, idx) => (
                                    <div key={idx} className={`p-4 rounded-xl border ${getColorClasses(item.color)}`}>
                                        <h3 className="font-bold text-sm mb-1 opacity-90">{item.title}</h3>
                                        <p className="text-base font-medium">{item.desc}</p>
                                    </div>
                                ))}
                            </div>

                            <div className="mt-6 p-4 bg-slate-50 rounded-xl border-l-4 border-slate-400">
                                <h3 className="font-bold text-slate-800 text-sm mb-1 uppercase tracking-wide">Objective Equation</h3>
                                <p className="text-slate-700 italic font-medium">{scenario.goal}</p>
                            </div>
                        </div>

                        {/* Footer / Actions */}
                        <div className="p-6 bg-slate-50 border-t border-slate-100 flex flex-col sm:flex-row gap-3">
                            <button 
                                onClick={() => onLoadEquations(scenario.equations, scenario.objective)}
                                className="flex-1 bg-blue-600 hover:bg-blue-700 text-white py-3 px-4 rounded-xl font-semibold shadow-sm hover:shadow-md transition-all flex items-center justify-center gap-2"
                            >
                                <Icon name="drafting-compass" />
                                Reveal & Graph
                            </button>
                            
                            <button 
                                onClick={() => onSave(scenario)}
                                className="flex-1 bg-white border border-slate-200 hover:border-blue-300 hover:text-blue-600 text-slate-700 py-3 px-4 rounded-xl font-semibold transition-all flex items-center justify-center gap-2"
                            >
                                <Icon name="save" />
                                Save for Later
                            </button>
                        </div>
                    </div>
                </div>
            );
        });

        const InequalityRow = memo(({ ineq, onChange, onRemove }) => {
            const handleChange = (field, value) => {
                onChange({ ...ineq, [field]: value });
            };

            return (
                <div className={`flex flex-col gap-2 p-3 border rounded-lg shadow-sm mb-2 transition-all hover:shadow-md ${ineq.visible ? 'bg-white border-slate-200' : 'bg-slate-50 border-slate-100 opacity-75'}`}>
                    <div className="flex items-center justify-between gap-2">
                        {/* Color Picker & Visibility */}
                        <div className="flex items-center gap-2">
                            <input 
                                type="color" 
                                value={ineq.color}
                                onChange={(e) => handleChange('color', e.target.value)}
                                className="w-6 h-6 rounded cursor-pointer border-none bg-transparent"
                                title="Change Line Color"
                            />
                            
                            {/* Global Visibility Toggle */}
                            <button 
                                onClick={() => handleChange('visible', !ineq.visible)}
                                className={`p-1 rounded hover:bg-slate-100 ${ineq.visible ? 'text-slate-600' : 'text-slate-300'}`}
                                title={ineq.visible ? "Hide Entire Equation" : "Show Equation"}
                            >
                                <Icon name={ineq.visible ? "eye" : "eye-off"} size={16} />
                            </button>
                        </div>
                        <button 
                            onClick={onRemove}
                            className="text-slate-400 hover:text-red-500 transition-colors"
                            title="Remove Equation"
                        >
                            <Icon name="trash-2" size={16} />
                        </button>
                    </div>

                    {ineq.visible && (
                        <>
                            <div className="flex items-center gap-1 text-sm">
                                <input 
                                    type="number" 
                                    value={ineq.a} 
                                    onChange={(e) => handleChange('a', Number(e.target.value))}
                                    className="w-12 p-1 border rounded text-center font-mono bg-slate-50 focus:ring-2 focus:ring-blue-200 outline-none"
                                    placeholder="A"
                                />
                                <span className="font-serif italic">x</span>
                                <span className="text-slate-400">+</span>
                                <input 
                                    type="number" 
                                    value={ineq.b} 
                                    onChange={(e) => handleChange('b', Number(e.target.value))}
                                    className="w-12 p-1 border rounded text-center font-mono bg-slate-50 focus:ring-2 focus:ring-blue-200 outline-none"
                                    placeholder="B"
                                />
                                <span className="font-serif italic">y</span>
                                
                                <select 
                                    value={ineq.sign} 
                                    onChange={(e) => handleChange('sign', e.target.value)}
                                    className="mx-1 p-1 bg-slate-100 rounded cursor-pointer font-bold text-slate-700"
                                >
                                    <option value="≤">≤</option>
                                    <option value="≥">≥</option>
                                    <option value="<">&lt;</option>
                                    <option value=">">&gt;</option>
                                </select>
                                
                                <input 
                                    type="number" 
                                    value={ineq.c} 
                                    onChange={(e) => handleChange('c', Number(e.target.value))}
                                    className="w-12 p-1 border rounded text-center font-mono bg-slate-50 focus:ring-2 focus:ring-blue-200 outline-none"
                                    placeholder="C"
                                />
                            </div>

                            <div className="flex items-center justify-between pt-2 border-t border-slate-100 mt-1">
                                <label className="flex items-center gap-2 cursor-pointer select-none group" title="Toggle the shaded region for student testing">
                                    <div className={`w-4 h-4 rounded border flex items-center justify-center transition-colors ${ineq.showRegion ? 'bg-blue-500 border-blue-500' : 'border-slate-300 bg-white'}`}>
                                        {ineq.showRegion && <Icon name="check" size={12} className="text-white" />}
                                    </div>
                                    <input 
                                        type="checkbox" 
                                        checked={ineq.showRegion} 
                                        onChange={(e) => handleChange('showRegion', e.target.checked)}
                                        className="hidden"
                                    />
                                    <span className="text-xs text-slate-600 group-hover:text-blue-600 font-medium">Shade Region</span>
                                </label>
                                <span className="text-xs text-slate-400 font-mono">
                                   {ineq.a}x + {ineq.b}y {ineq.sign} {ineq.c}
                                </span>
                            </div>
                        </>
                    )}
                </div>
            );
        });

        const CanvasGraph = memo(({ inequalities, showFeasibleOnly, objective }) => {
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            
            // View State
            const [scale, setScale] = useState(40); // Pixels per unit
            const [offset, setOffset] = useState({ x: 0, y: 0 }); // Center in pixels relative to canvas center
            const [isDragging, setIsDragging] = useState(false);
            const [lastPos, setLastPos] = useState({ x: 0, y: 0 });

            useEffect(() => {
                const handleResize = () => {
                    if (containerRef.current && canvasRef.current) {
                        const { width, height } = containerRef.current.getBoundingClientRect();
                        const dpr = window.devicePixelRatio || 1;
                        canvasRef.current.width = width * dpr;
                        canvasRef.current.height = height * dpr;
                        canvasRef.current.style.width = `${width}px`;
                        canvasRef.current.style.height = `${height}px`;
                        draw();
                    }
                };
                window.addEventListener('resize', handleResize);
                handleResize();
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            // Use LayoutEffect for smoother synchronization with browser paint
            useLayoutEffect(() => {
                draw();
            }, [inequalities, scale, offset, showFeasibleOnly, objective]);

            const draw = () => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);

                const originX = width / 2 + offset.x;
                const originY = height / 2 + offset.y;

                const toPxX = (x) => originX + x * scale;
                const toPxY = (y) => originY - y * scale; 

                const toMathX = (px) => (px - originX) / scale;
                const toMathY = (py) => (originY - py) / scale;

                const xMin = toMathX(0);
                const xMax = toMathX(width);
                const yMin = toMathY(height); 
                const yMax = toMathY(0);
                
                const mathYMin = Math.min(yMin, yMax);
                const mathYMax = Math.max(yMin, yMax);

                // --- 1. Draw Feasible Region Background FIRST ---
                if (showFeasibleOnly) {
                    ctx.save();
                    // Fill entire screen with green
                    ctx.fillStyle = 'rgba(34, 197, 94, 0.4)'; 
                    ctx.fillRect(0, 0, width, height);
                    
                    // Cut out the invalid areas
                    ctx.globalCompositeOperation = 'destination-out';
                    
                    inequalities.forEach(ineq => {
                        if (!ineq.visible || !ineq.showRegion) return;
                        drawHalfPlane(ctx, ineq, xMin, xMax, mathYMin, mathYMax, toPxX, toPxY, true); 
                    });
                    
                    ctx.restore();
                }

                // --- 2. Draw Grid and Axes (So they are ON TOP of the feasible shading) ---
                drawGridAndAxes(ctx, width, height, xMin, xMax, mathYMin, mathYMax, toPxX, toPxY, originX, originY);

                // --- 3. Draw Inequality Lines ---
                inequalities.forEach(ineq => {
                    if (!ineq.visible) return;
                    if (!showFeasibleOnly && ineq.showRegion) {
                        // If NOT in "feasible only" mode, draw individual shaded regions
                        ctx.fillStyle = ineq.color + '33';
                        ctx.save();
                        drawHalfPlane(ctx, ineq, xMin, xMax, mathYMin, mathYMax, toPxX, toPxY, false);
                        ctx.restore();
                    }
                    drawLine(ctx, ineq, xMin, xMax, mathYMin, mathYMax, toPxX, toPxY);
                });

                // --- 4. Draw Objective Line ---
                if (objective && objective.visible) {
                    drawObjectiveLine(ctx, objective, xMin, xMax, mathYMin, mathYMax, toPxX, toPxY);
                }
            };

            const drawObjectiveLine = (ctx, obj, xMin, xMax, yMin, yMax, toPxX, toPxY) => {
                // Ax + By = C
                const pts = getIntersections(obj.a, obj.b, obj.c, xMin, xMax, yMin, yMax);
                if (pts.length < 2) return;
                
                pts.sort((p1, p2) => p1.x - p2.x);

                ctx.save();
                ctx.beginPath();
                ctx.moveTo(toPxX(pts[0].x), toPxY(pts[0].y));
                ctx.lineTo(toPxX(pts[1].x), toPxY(pts[1].y));
                
                ctx.lineWidth = 4;
                ctx.strokeStyle = '#4f46e5'; // Indigo-600
                ctx.setLineDash([15, 10]); // Large dashes
                ctx.stroke();
                
                // Draw label
                const midX = (pts[0].x + pts[1].x) / 2;
                const midY = (pts[0].y + pts[1].y) / 2;
                
                // Only draw label if middle is somewhat visible
                if (midX >= xMin && midX <= xMax && midY >= yMin && midY <= yMax) {
                    ctx.fillStyle = '#4f46e5';
                    ctx.font = 'bold 14px monospace';
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 4;
                    const text = `P = ${obj.c.toFixed(1)}`; // Added decimal formatting
                    ctx.strokeText(text, toPxX(midX) + 15, toPxY(midY) - 15);
                    ctx.fillText(text, toPxX(midX) + 15, toPxY(midY) - 15);
                }
                
                ctx.restore();
            };

            const drawGridAndAxes = (ctx, width, height, xMin, xMax, yMin, yMax, toPxX, toPxY, originX, originY) => {
                ctx.save(); // Save context to protect against outside state changes
                
                ctx.lineWidth = 1;
                ctx.strokeStyle = '#cbd5e1'; 
                ctx.fillStyle = '#475569';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';

                let step = 1;
                if (scale < 20) step = 5;
                if (scale < 10) step = 10;
                if (scale < 2) step = 50;
                
                const startX = Math.floor(xMin / step) * step;
                const endX = Math.ceil(xMax / step) * step;
                
                // Draw vertical grid lines
                for (let x = startX; x <= endX; x += step) {
                    const px = toPxX(x);
                    ctx.beginPath();
                    ctx.moveTo(px, 0);
                    ctx.lineTo(px, height);
                    ctx.stroke();

                    if (x !== 0 && originY >= -20 && originY <= height + 20) {
                        ctx.fillText(x.toString(), px, originY + 8);
                    }
                }

                const startY = Math.floor(yMin / step) * step;
                const endY = Math.ceil(yMax / step) * step;
                
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';

                // Draw horizontal grid lines
                for (let y = startY; y <= endY; y += step) {
                    const py = toPxY(y);
                    ctx.beginPath();
                    ctx.moveTo(0, py);
                    ctx.lineTo(width, py);
                    ctx.stroke();

                    if (y !== 0 && originX >= -20 && originX <= width + 20) {
                        ctx.fillText(y.toString(), originX - 8, py);
                    }
                }

                // Draw Axes (Thicker)
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#475569';
                
                if (originY >= 0 && originY <= height) {
                    ctx.beginPath();
                    ctx.moveTo(0, originY);
                    ctx.lineTo(width, originY);
                    ctx.stroke();
                }

                if (originX >= 0 && originX <= width) {
                    ctx.beginPath();
                    ctx.moveTo(originX, 0);
                    ctx.lineTo(originX, height);
                    ctx.stroke();
                }
                
                if (originX >= 0 && originX <= width && originY >= 0 && originY <= height) {
                     ctx.fillStyle = '#475569';
                     ctx.fillText("0", originX - 8, originY + 8);
                }
                
                ctx.restore();
            };

            const drawLine = (ctx, ineq, xMin, xMax, yMin, yMax, toPxX, toPxY) => {
                const { a, b, c, sign, color } = ineq;
                const pts = getIntersections(a, b, c, xMin, xMax, yMin, yMax);
                
                if (pts.length < 2) return; 

                pts.sort((p1, p2) => p1.x - p2.x);

                ctx.beginPath();
                ctx.moveTo(toPxX(pts[0].x), toPxY(pts[0].y));
                ctx.lineTo(toPxX(pts[1].x), toPxY(pts[1].y));
                
                ctx.lineWidth = 3;
                ctx.strokeStyle = color;
                if (sign === '<' || sign === '>') {
                    ctx.setLineDash([10, 10]);
                } else {
                    ctx.setLineDash([]);
                }
                ctx.stroke();
                ctx.setLineDash([]);
            };

            const drawHalfPlane = (ctx, ineq, xMin, xMax, yMin, yMax, toPxX, toPxY, drawInvalid = false) => {
                const { a, b, c } = ineq;
                const corners = [
                    { x: xMin, y: yMin },
                    { x: xMax, y: yMin },
                    { x: xMax, y: yMax },
                    { x: xMin, y: yMax }
                ];

                let intersections = getIntersections(a, b, c, xMin, xMax, yMin, yMax);
                
                if (intersections.length < 2) {
                    const cx = (xMin + xMax) / 2;
                    const cy = (yMin + yMax) / 2;
                    let satisfies = checkInequality(cx, cy, ineq);
                    if (drawInvalid) satisfies = !satisfies;

                    if (satisfies) {
                        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    }
                    return;
                }

                let polyPoints = [...intersections];
                corners.forEach(corner => {
                     let valid = checkInequality(corner.x, corner.y, ineq);
                     if (drawInvalid) valid = !valid;
                     if (valid) polyPoints.push(corner);
                });

                if (polyPoints.length < 3) return;

                const center = polyPoints.reduce((acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }), { x: 0, y: 0 });
                center.x /= polyPoints.length;
                center.y /= polyPoints.length;

                polyPoints.sort((p1, p2) => {
                    return Math.atan2(p1.y - center.y, p1.x - center.x) - Math.atan2(p2.y - center.y, p2.x - center.x);
                });

                ctx.beginPath();
                ctx.moveTo(toPxX(polyPoints[0].x), toPxY(polyPoints[0].y));
                for (let i = 1; i < polyPoints.length; i++) {
                    ctx.lineTo(toPxX(polyPoints[i].x), toPxY(polyPoints[i].y));
                }
                ctx.closePath();
                
                if (drawInvalid) ctx.fillStyle = '#000000'; 
                ctx.fill();
            };

            const handleMouseDown = (e) => {
                setIsDragging(true);
                setLastPos({ x: e.clientX, y: e.clientY });
            };
            
            const handleMouseMove = (e) => {
                if (!isDragging) return;
                const dx = e.clientX - lastPos.x;
                const dy = e.clientY - lastPos.y;
                setOffset(prev => ({ x: prev.x + dx, y: prev.y + dy }));
                setLastPos({ x: e.clientX, y: e.clientY });
            };
            
            const handleMouseUp = () => setIsDragging(false);
            
            const handleWheel = (e) => {
                e.preventDefault();
                const zoomSpeed = 0.1;
                const newScale = e.deltaY > 0 ? scale * (1 - zoomSpeed) : scale * (1 + zoomSpeed);
                if (newScale > 1 && newScale < 1000) setScale(newScale);
            };

            return (
                <div 
                    ref={containerRef} 
                    className="w-full h-full cursor-move bg-white relative"
                    onMouseDown={handleMouseDown}
                    onMouseMove={handleMouseMove}
                    onMouseUp={handleMouseUp}
                    onMouseLeave={handleMouseUp}
                    onWheel={handleWheel}
                >
                    <canvas ref={canvasRef} className="absolute top-0 left-0" />
                    <div className="absolute bottom-6 right-6 flex flex-col gap-2 bg-white p-2 rounded-lg shadow-lg border border-slate-200">
                        <button onClick={() => setScale(s => Math.min(s * 1.2, 500))} className="p-2 hover:bg-slate-100 rounded text-slate-600"><Icon name="zoom-in" /></button>
                        <button onClick={() => setScale(s => Math.max(s / 1.2, 5))} className="p-2 hover:bg-slate-100 rounded text-slate-600"><Icon name="zoom-out" /></button>
                        <button onClick={() => { setOffset({x:0, y:0}); setScale(40); }} className="p-2 hover:bg-slate-100 rounded text-slate-600" title="Reset View"><Icon name="refresh-ccw" /></button>
                    </div>
                </div>
            );
        });

        const App = () => {
            const [inequalities, setInequalities] = useState([
                { id: 1, a: 1, b: 1, c: 6, sign: '≤', color: '#3b82f6', showRegion: true, visible: true },
            ]);
            
            const [objective, setObjective] = useState({ a: 1, b: 1, c: 0, visible: false });
            const [showFeasibleOnly, setShowFeasibleOnly] = useState(false);
            const [activeScenario, setActiveScenario] = useState(null);
            const [savedScenario, setSavedScenario] = useState(null);

            // Use Callback to prevent function recreation on every render, allowing InequalityRow to be memoized
            const addInequality = useCallback((data = null) => {
                setInequalities(prev => {
                    const newId = Math.max(0, ...prev.map(i => i.id)) + 1;
                    const defaults = data || { a: 1, b: 1, c: 5, sign: '≤' };
                    return [
                        ...prev, 
                        { 
                            id: newId, 
                            ...defaults,
                            color: getRandomColor(), 
                            showRegion: true, 
                            visible: true 
                        }
                    ];
                });
            }, []);

            const updateInequality = useCallback((updated) => {
                setInequalities(prev => prev.map(i => i.id === updated.id ? updated : i));
            }, []);

            const removeInequality = useCallback((id) => {
                setInequalities(prev => prev.filter(i => i.id !== id));
            }, []);

            const generateRandomScenario = useCallback(() => {
                const random = SCENARIOS[Math.floor(Math.random() * SCENARIOS.length)];
                setActiveScenario(random);
            }, []);

            const loadScenarioEquations = useCallback((eqs, objFunc) => {
                const newEqs = eqs.map((eq, idx) => ({
                    id: idx + 1,
                    ...eq,
                    color: getRandomColor(),
                    showRegion: true,
                    visible: true
                }));
                setInequalities(newEqs);
                
                if (objFunc) {
                    setObjective({ 
                        a: objFunc.a, 
                        b: objFunc.b, 
                        c: objFunc.startVal || 0, 
                        visible: true 
                    });
                } else {
                    setObjective(prev => ({ ...prev, visible: false }));
                }

                setActiveScenario(null); 
                setSavedScenario(null); 
                setShowFeasibleOnly(true);
            }, []);

            const saveScenarioForLater = useCallback((scenario) => {
                setSavedScenario(scenario);
                setActiveScenario(null);
            }, []);

            return (
                <div className="flex h-screen w-full flex-col md:flex-row relative">
                    <ScenarioModal 
                        scenario={activeScenario} 
                        onClose={() => setActiveScenario(null)} 
                        onLoadEquations={loadScenarioEquations}
                        onSave={saveScenarioForLater}
                    />

                    {/* Sidebar */}
                    <div className="w-full md:w-96 bg-slate-50 border-r border-slate-200 flex flex-col shadow-xl z-10 h-full">
                        <div className="p-4 bg-white border-b border-slate-200">
                            <h1 className="text-xl font-bold text-slate-800 flex items-center gap-2">
                                <Icon name="drafting-compass" className="text-blue-600" />
                                LP Explorer
                            </h1>
                            <p className="text-sm text-slate-500 mt-1">Grade 11 Mathematics Tool</p>
                        </div>

                        <div className="flex-1 overflow-y-auto p-4">
                            {/* Actions Section */}
                            <div className="mb-6 flex flex-col gap-2">
                                <h2 className="text-xs font-bold text-slate-400 uppercase tracking-wider mb-1">Actions</h2>
                                
                                {savedScenario && (
                                    <button 
                                        onClick={() => setActiveScenario(savedScenario)}
                                        className="w-full mb-2 bg-emerald-50 border border-emerald-200 p-3 rounded-lg flex items-center gap-3 hover:bg-emerald-100 transition-colors group text-left"
                                    >
                                        <div className="bg-emerald-500 text-white p-2 rounded-lg group-hover:scale-105 transition-transform">
                                            <Icon name="play" size={16} fill="currentColor" />
                                        </div>
                                        <div>
                                            <span className="text-xs font-bold text-emerald-600 uppercase tracking-wider block">Resume Scenario</span>
                                            <span className="text-sm font-bold text-slate-700">{savedScenario.title}</span>
                                        </div>
                                    </button>
                                )}

                                <button 
                                    onClick={generateRandomScenario}
                                    className="w-full flex items-center justify-center gap-2 bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 text-white py-3 px-4 rounded-lg shadow-sm transition-all text-sm font-semibold"
                                >
                                    <Icon name="book-open" size={18} />
                                    Generate Scenario
                                </button>
                                
                                <button 
                                    onClick={() => addInequality()}
                                    className="w-full flex items-center justify-center gap-2 border border-slate-300 bg-white hover:bg-slate-50 text-slate-700 py-2.5 px-4 rounded-lg transition-all text-sm font-medium"
                                >
                                    <Icon name="plus" size={16} />
                                    Add Custom Equation
                                </button>
                            </div>

                            {/* Optimization / Objective Function Section */}
                            <div className="mb-6">
                                <div className="flex items-center justify-between mb-2">
                                    <h2 className="text-xs font-bold text-slate-400 uppercase tracking-wider flex items-center gap-1">
                                        <Icon name="sliders" size={12} /> Optimization
                                    </h2>
                                    <button
                                        onClick={() => setObjective(prev => ({...prev, visible: !prev.visible}))}
                                        className={`text-xs px-2 py-1 rounded-md font-bold transition-all ${objective.visible ? 'bg-indigo-100 text-indigo-700 ring-2 ring-indigo-200' : 'bg-slate-200 text-slate-500 hover:bg-slate-300'}`}
                                    >
                                        {objective.visible ? 'ACTIVE' : 'OFF'}
                                    </button>
                                </div>
                                
                                {objective.visible && (
                                    <div className="bg-white p-4 rounded-xl border border-indigo-200 shadow-sm animate-in fade-in slide-in-from-top-2 relative overflow-hidden">
                                        <div className="absolute top-0 left-0 w-1 h-full bg-indigo-500"></div>
                                        
                                        <p className="text-xs text-indigo-600 font-semibold mb-2">Objective Function Line</p>
                                        
                                        <div className="flex items-center gap-2 mb-4 text-sm font-mono justify-center bg-slate-50 p-2 rounded-lg border border-slate-100">
                                            <span className="font-serif italic text-indigo-700 font-bold text-lg">P</span>
                                            <span className="text-slate-400">=</span>
                                            <input 
                                                type="number" 
                                                value={objective.a}
                                                onChange={(e) => setObjective(prev => ({...prev, a: Number(e.target.value)}))}
                                                className="w-14 p-1 border border-indigo-100 rounded text-center bg-white focus:ring-2 focus:ring-indigo-200 outline-none font-bold text-slate-700"
                                            />
                                            <span className="font-serif italic text-slate-600">x</span>
                                            <span className="text-slate-400">+</span>
                                            <input 
                                                type="number" 
                                                value={objective.b}
                                                onChange={(e) => setObjective(prev => ({...prev, b: Number(e.target.value)}))}
                                                className="w-14 p-1 border border-indigo-100 rounded text-center bg-white focus:ring-2 focus:ring-indigo-200 outline-none font-bold text-slate-700"
                                            />
                                            <span className="font-serif italic text-slate-600">y</span>
                                        </div>
                                        
                                        <div className="space-y-2">
                                            <div className="flex justify-between items-center text-xs text-slate-500 font-medium">
                                                <span>Slide to find vertex</span>
                                                <div className="flex items-center gap-2">
                                                    <span className="text-indigo-600 font-bold">P =</span>
                                                    <input 
                                                        type="number"
                                                        step="0.1"
                                                        value={objective.c}
                                                        onChange={(e) => setObjective(prev => ({...prev, c: parseFloat(e.target.value) || 0}))}
                                                        className="w-20 p-1 text-right border border-indigo-200 rounded text-indigo-700 font-bold bg-white text-sm"
                                                    />
                                                </div>
                                            </div>
                                            <input 
                                                type="range" 
                                                min="-100" 
                                                max="500" 
                                                step="0.1"
                                                value={objective.c}
                                                onChange={(e) => setObjective(prev => ({...prev, c: Number(e.target.value)}))}
                                                className="w-full accent-indigo-600 h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer hover:bg-slate-300 transition-colors"
                                            />
                                        </div>
                                    </div>
                                )}
                            </div>

                            <div className="flex justify-between items-center mb-2">
                                <h2 className="text-xs font-bold text-slate-400 uppercase tracking-wider">Constraints</h2>
                                <span className="text-xs text-slate-400 bg-slate-100 px-2 py-0.5 rounded-full">{inequalities.length}</span>
                            </div>

                            <div className="space-y-2 pb-4">
                                {inequalities.map(ineq => (
                                    <InequalityRow 
                                        key={ineq.id} 
                                        ineq={ineq} 
                                        onChange={updateInequality} 
                                        onRemove={() => removeInequality(ineq.id)}
                                    />
                                ))}
                            </div>
                            
                            {inequalities.length === 0 && (
                                <div className="text-center py-8 text-slate-400 border-2 border-dashed border-slate-200 rounded-lg">
                                    <p>No equations added.</p>
                                    <p className="text-xs mt-1">Generate a scenario to start.</p>
                                </div>
                            )}
                        </div>

                        <div className="p-4 bg-white border-t border-slate-200">
                            <div className="flex flex-col gap-3">
                                <label className="flex items-center justify-between p-3 rounded-lg border border-slate-200 cursor-pointer hover:bg-slate-50 transition-colors">
                                    <div className="flex flex-col">
                                        <span className="font-semibold text-slate-700 text-sm">Feasible Region Only</span>
                                        <span className="text-xs text-slate-500">Highlight valid intersection</span>
                                    </div>
                                    <div className={`w-12 h-6 rounded-full p-1 transition-colors ${showFeasibleOnly ? 'bg-green-500' : 'bg-slate-300'}`}>
                                        <div className={`bg-white w-4 h-4 rounded-full shadow-sm transform transition-transform ${showFeasibleOnly ? 'translate-x-6' : ''}`}></div>
                                    </div>
                                    <input 
                                        type="checkbox" 
                                        checked={showFeasibleOnly}
                                        onChange={(e) => setShowFeasibleOnly(e.target.checked)}
                                        className="hidden"
                                    />
                                </label>
                            </div>
                        </div>
                    </div>

                    {/* Main Canvas Area */}
                    <div className="flex-1 relative bg-gray-50 overflow-hidden">
                        <CanvasGraph inequalities={inequalities} showFeasibleOnly={showFeasibleOnly} objective={objective} />
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
