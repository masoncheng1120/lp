<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linear Programming Explorer</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-slate-50 text-slate-900 h-screen overflow-hidden">
    <div id="root" class="h-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- Utility Functions ---

        const getRandomColor = () => {
            const colors = [
                '#ef4444', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899', '#06b6d4'
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        };

        // --- Real Life Scenarios Data ---
        const SCENARIOS = [
            {
                id: 'furniture',
                title: "The Furniture Workshop",
                icon: "hammer",
                type: "Production Optimization",
                intro: "A local artisan runs a small furniture workshop that specializes in handcrafted chairs (x) and tables (y). The artisan wants to optimize production to maximize profit, but is limited by available labor hours in two key departments: Carpentry and Painting.",
                constraints: [
                    { title: "Carpentry Department", desc: "Each chair requires 2 hours of carpentry, while a table is more complex and needs 3 hours. The department has a maximum of 24 labor hours available per week.", color: "blue" },
                    { title: "Painting Department", desc: "Each chair needs 1 hour for painting and varnishing, whereas a table requires 2 hours. The painting team has only 10 hours available this week.", color: "orange" },
                    { title: "Physical Constraints", desc: "You cannot produce negative quantities of furniture (x ≥ 0, y ≥ 0).", color: "slate" }
                ],
                goal: "Determine the feasible production quantities (x, y) that satisfy all labor constraints.",
                equations: [
                    { a: 2, b: 3, c: 24, sign: '≤' },
                    { a: 1, b: 2, c: 10, sign: '≤' },
                    { a: 1, b: 0, c: 0, sign: '≥' },
                    { a: 0, b: 1, c: 0, sign: '≥' }
                ]
            },
            {
                id: 'diet',
                title: "Clinical Diet Plan",
                icon: "apple",
                type: "Health & Nutrition",
                intro: "A clinical nutritionist is designing a specialized diet plan for a patient using two different food supplements, Food A (x) and Food B (y). The goal is to meet minimum daily vitamin requirements while managing the intake effectively.",
                constraints: [
                    { title: "Vitamin C Requirement", desc: "Food A is rich in Vitamin C (2 units/g), while Food B contains 1 unit/g. The patient must consume at least 8 units of Vitamin C daily.", color: "emerald" },
                    { title: "Vitamin D Requirement", desc: "Food A contains 1 unit of Vitamin D per gram, and Food B contains 2 units per gram. The daily requirement is at least 10 units.", color: "amber" },
                    { title: "Reality Constraint", desc: "Food amounts cannot be negative (x ≥ 0, y ≥ 0).", color: "slate" }
                ],
                goal: "Visualize the region of all possible diet combinations that meet the nutritional minimums.",
                equations: [
                    { a: 2, b: 1, c: 8, sign: '≥' },
                    { a: 1, b: 2, c: 10, sign: '≥' },
                    { a: 1, b: 0, c: 0, sign: '≥' },
                    { a: 0, b: 1, c: 0, sign: '≥' }
                ]
            },
            {
                id: 'investment',
                title: "Portfolio Strategy",
                icon: "dollar-sign",
                type: "Financial Planning",
                intro: "A financial advisor is building a diversified portfolio for a client, allocating funds between High-Growth Tech Stocks (x) and Secure Government Bonds (y). All amounts are measured in thousands of dollars.",
                constraints: [
                    { title: "Total Capital Limit", desc: "The client has a total budget of $20,000 available for investment. The sum of both investments cannot exceed this amount (x + y ≤ 20).", color: "indigo" },
                    { title: "Risk Management Cap", desc: "To mitigate risk, the advisor limits the investment in volatile Tech Stocks to a maximum of $12,000.", color: "rose" },
                    { title: "Stability Minimum", desc: "To ensure stability, the portfolio requires a minimum investment of $4,000 in Government Bonds.", color: "cyan" },
                    { title: "Basic Constraints", desc: "Investment amounts cannot be negative.", color: "slate" }
                ],
                goal: "Identify the feasible investment strategy that adheres to the budget and risk management rules.",
                equations: [
                    { a: 1, b: 1, c: 20, sign: '≤' },
                    { a: 1, b: 0, c: 12, sign: '≤' },
                    { a: 0, b: 1, c: 4, sign: '≥' },
                    { a: 1, b: 0, c: 0, sign: '≥' },
                    { a: 0, b: 1, c: 0, sign: '≥' }
                ]
            }
        ];

        // --- Math Logic for Geometry ---

        const checkInequality = (x, y, ineq) => {
            const val = ineq.a * x + ineq.b * y;
            switch (ineq.sign) {
                case '≤': return val <= ineq.c;
                case '≥': return val >= ineq.c;
                case '<': return val < ineq.c;
                case '>': return val > ineq.c;
                default: return false;
            }
        };

        const getIntersections = (A, B, C, xMin, xMax, yMin, yMax) => {
            const points = [];
            const TOLERANCE = 1e-10;

            const addIfValid = (x, y) => {
                const xValid = x >= xMin - TOLERANCE && x <= xMax + TOLERANCE;
                const yValid = y >= yMin - TOLERANCE && y <= yMax + TOLERANCE;
                if (xValid && yValid) {
                    points.push({ x, y });
                }
            };

            if (Math.abs(B) > TOLERANCE) {
                addIfValid(xMin, (C - A * xMin) / B);
                addIfValid(xMax, (C - A * xMax) / B);
            }

            if (Math.abs(A) > TOLERANCE) {
                addIfValid((C - B * yMin) / A, yMin);
                addIfValid((C - B * yMax) / A, yMax);
            }

            return points;
        };

        // --- Components ---

        const ICONS = {
            'plus': <><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></>,
            'trash-2': <><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></>,
            'check': <polyline points="20 6 9 17 4 12"></polyline>,
            'eye': <><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></>,
            'eye-off': <><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line></>,
            'zoom-in': <><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></>,
            'zoom-out': <><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line></>,
            'refresh-ccw': <><polyline points="1 4 1 10 7 10"></polyline><polyline points="23 20 23 14 17 14"></polyline><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path></>,
            'drafting-compass': <><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></>,
            'book-open': <><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></>,
            'x': <><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></>,
            'dollar-sign': <><line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path></>,
            'hammer': <><path d="M15 12l-8.5 8.5c-.83.83-2.17.83-3 0 0 0 0 0 0 0a2.12 2.12 0 0 1 0-3L12 9"></path><path d="M17.64 15L22 10.64"></path><path d="M20.91 11.7l-1.25-1.25c-.6-.6-.93-1.4-.93-2.25V7.86c0-.55-.45-1-1-1H14.14c-.85 0-1.65-.33-2.25-.93L10.64 4.64"></path></>,
            'apple': <><path d="M12 20.94c1.5 0 2.75 1.06 4 1.06 3 0 6-8 6-12.22A4.91 4.91 0 0 0 17 5c-2.22 0-4 1.44-5 2-1-.56-2.78-2-5-2a4.9 4.9 0 0 0-5 4.78C2 14 5 22 8 22c1.25 0 2.5-1.06 4-1.06Z"></path><path d="M10 2c1 .5 2 2 2 5"></path></>,
            'save': <><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></>,
            'play': <polygon points="5 3 19 12 5 21 5 3"></polygon>
        };

        const Icon = ({ name, size = 16, className }) => {
            const content = ICONS[name] || null;
            return (
                <svg 
                    xmlns="http://www.w3.org/2000/svg" 
                    width={size} 
                    height={size} 
                    viewBox="0 0 24 24" 
                    fill="none" 
                    stroke="currentColor" 
                    strokeWidth="2" 
                    strokeLinecap="round" 
                    strokeLinejoin="round" 
                    className={className}
                >
                    {content}
                </svg>
            );
        };

        const ScenarioModal = ({ scenario, onClose, onLoadEquations, onSave }) => {
            if (!scenario) return null;

            const getColorClasses = (color) => {
                const map = {
                    blue: "bg-blue-50 border-blue-200 text-blue-800",
                    orange: "bg-orange-50 border-orange-200 text-orange-800",
                    slate: "bg-slate-50 border-slate-200 text-slate-600",
                    emerald: "bg-emerald-50 border-emerald-200 text-emerald-800",
                    amber: "bg-amber-50 border-amber-200 text-amber-800",
                    indigo: "bg-indigo-50 border-indigo-200 text-indigo-800",
                    rose: "bg-rose-50 border-rose-200 text-rose-800",
                    cyan: "bg-cyan-50 border-cyan-200 text-cyan-800",
                };
                return map[color] || map.blue;
            };

            return (
                <div className="absolute inset-0 z-50 flex items-center justify-center bg-slate-900/60 backdrop-blur-sm p-4 animate-in fade-in duration-200">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-lg w-full overflow-hidden border border-slate-200">
                        {/* Header */}
                        <div className="bg-white border-b border-slate-100 p-6 flex justify-between items-start">
                            <div className="flex gap-4">
                                <div className="p-3 bg-blue-100 text-blue-600 rounded-xl shadow-sm">
                                    <Icon name={scenario.icon || 'book-open'} size={24} />
                                </div>
                                <div>
                                    <span className="text-xs font-bold text-blue-600 uppercase tracking-wider">{scenario.type || 'Scenario'}</span>
                                    <h2 className="text-2xl font-bold text-slate-800 mt-1">{scenario.title}</h2>
                                </div>
                            </div>
                            <button onClick={onClose} className="text-slate-400 hover:text-slate-600 p-2 hover:bg-slate-100 rounded-lg transition-colors">
                                <Icon name="x" size={20} />
                            </button>
                        </div>
                        
                        {/* Body */}
                        <div className="p-6 overflow-y-auto max-h-[60vh]">
                            <p className="text-slate-600 text-lg mb-6 leading-relaxed">
                                {scenario.intro}
                            </p>
                            
                            <div className="space-y-3">
                                {scenario.constraints.map((item, idx) => (
                                    <div key={idx} className={`p-4 rounded-xl border ${getColorClasses(item.color)}`}>
                                        <h3 className="font-bold text-sm mb-1 opacity-90">{item.title}</h3>
                                        <p className="text-base font-medium">{item.desc}</p>
                                    </div>
                                ))}
                            </div>

                            <div className="mt-6 p-4 bg-slate-50 rounded-xl border-l-4 border-slate-400">
                                <h3 className="font-bold text-slate-800 text-sm mb-1 uppercase tracking-wide">Objective</h3>
                                <p className="text-slate-700 italic font-medium">{scenario.goal}</p>
                            </div>
                        </div>

                        {/* Footer / Actions */}
                        <div className="p-6 bg-slate-50 border-t border-slate-100 flex flex-col sm:flex-row gap-3">
                            <button 
                                onClick={() => onLoadEquations(scenario.equations)}
                                className="flex-1 bg-blue-600 hover:bg-blue-700 text-white py-3 px-4 rounded-xl font-semibold shadow-sm hover:shadow-md transition-all flex items-center justify-center gap-2"
                            >
                                <Icon name="drafting-compass" />
                                Reveal & Graph
                            </button>
                            
                            <button 
                                onClick={() => onSave(scenario)}
                                className="flex-1 bg-white border border-slate-200 hover:border-blue-300 hover:text-blue-600 text-slate-700 py-3 px-4 rounded-xl font-semibold transition-all flex items-center justify-center gap-2"
                            >
                                <Icon name="save" />
                                Save for Later
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const InequalityRow = ({ ineq, onChange, onRemove }) => {
            const handleChange = (field, value) => {
                onChange({ ...ineq, [field]: value });
            };

            return (
                <div className={`flex flex-col gap-2 p-3 border rounded-lg shadow-sm mb-2 transition-all hover:shadow-md ${ineq.visible ? 'bg-white border-slate-200' : 'bg-slate-50 border-slate-100 opacity-75'}`}>
                    <div className="flex items-center justify-between gap-2">
                        {/* Color Picker & Visibility */}
                        <div className="flex items-center gap-2">
                            <input 
                                type="color" 
                                value={ineq.color}
                                onChange={(e) => handleChange('color', e.target.value)}
                                className="w-6 h-6 rounded cursor-pointer border-none bg-transparent"
                                title="Change Line Color"
                            />
                            
                            {/* Global Visibility Toggle */}
                            <button 
                                onClick={() => handleChange('visible', !ineq.visible)}
                                className={`p-1 rounded hover:bg-slate-100 ${ineq.visible ? 'text-slate-600' : 'text-slate-300'}`}
                                title={ineq.visible ? "Hide Entire Equation" : "Show Equation"}
                            >
                                <Icon name={ineq.visible ? "eye" : "eye-off"} size={16} />
                            </button>
                        </div>
                        <button 
                            onClick={onRemove}
                            className="text-slate-400 hover:text-red-500 transition-colors"
                            title="Remove Equation"
                        >
                            <Icon name="trash-2" size={16} />
                        </button>
                    </div>

                    {ineq.visible && (
                        <>
                            <div className="flex items-center gap-1 text-sm">
                                <input 
                                    type="number" 
                                    value={ineq.a} 
                                    onChange={(e) => handleChange('a', Number(e.target.value))}
                                    className="w-12 p-1 border rounded text-center font-mono bg-slate-50 focus:ring-2 focus:ring-blue-200 outline-none"
                                    placeholder="A"
                                />
                                <span className="font-serif italic">x</span>
                                <span className="text-slate-400">+</span>
                                <input 
                                    type="number" 
                                    value={ineq.b} 
                                    onChange={(e) => handleChange('b', Number(e.target.value))}
                                    className="w-12 p-1 border rounded text-center font-mono bg-slate-50 focus:ring-2 focus:ring-blue-200 outline-none"
                                    placeholder="B"
                                />
                                <span className="font-serif italic">y</span>
                                
                                <select 
                                    value={ineq.sign} 
                                    onChange={(e) => handleChange('sign', e.target.value)}
                                    className="mx-1 p-1 bg-slate-100 rounded cursor-pointer font-bold text-slate-700"
                                >
                                    <option value="≤">≤</option>
                                    <option value="≥">≥</option>
                                    <option value="<">&lt;</option>
                                    <option value=">">&gt;</option>
                                </select>
                                
                                <input 
                                    type="number" 
                                    value={ineq.c} 
                                    onChange={(e) => handleChange('c', Number(e.target.value))}
                                    className="w-12 p-1 border rounded text-center font-mono bg-slate-50 focus:ring-2 focus:ring-blue-200 outline-none"
                                    placeholder="C"
                                />
                            </div>

                            <div className="flex items-center justify-between pt-2 border-t border-slate-100 mt-1">
                                <label className="flex items-center gap-2 cursor-pointer select-none group" title="Toggle the shaded region for student testing">
                                    <div className={`w-4 h-4 rounded border flex items-center justify-center transition-colors ${ineq.showRegion ? 'bg-blue-500 border-blue-500' : 'border-slate-300 bg-white'}`}>
                                        {ineq.showRegion && <Icon name="check" size={12} className="text-white" />}
                                    </div>
                                    <input 
                                        type="checkbox" 
                                        checked={ineq.showRegion} 
                                        onChange={(e) => handleChange('showRegion', e.target.checked)}
                                        className="hidden"
                                    />
                                    <span className="text-xs text-slate-600 group-hover:text-blue-600 font-medium">Shade Region</span>
                                </label>
                                <span className="text-xs text-slate-400 font-mono">
                                   {ineq.a}x + {ineq.b}y {ineq.sign} {ineq.c}
                                </span>
                            </div>
                        </>
                    )}
                </div>
            );
        };

        const CanvasGraph = ({ inequalities, showFeasibleOnly }) => {
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            
            // View State
            const [scale, setScale] = useState(40); // Pixels per unit
            const [offset, setOffset] = useState({ x: 0, y: 0 }); // Center in pixels relative to canvas center
            const [isDragging, setIsDragging] = useState(false);
            const [lastPos, setLastPos] = useState({ x: 0, y: 0 });

            useEffect(() => {
                const handleResize = () => {
                    if (containerRef.current && canvasRef.current) {
                        const { width, height } = containerRef.current.getBoundingClientRect();
                        const dpr = window.devicePixelRatio || 1;
                        canvasRef.current.width = width * dpr;
                        canvasRef.current.height = height * dpr;
                        canvasRef.current.style.width = `${width}px`;
                        canvasRef.current.style.height = `${height}px`;
                        draw();
                    }
                };
                window.addEventListener('resize', handleResize);
                handleResize();
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            useEffect(() => {
                draw();
            }, [inequalities, scale, offset, showFeasibleOnly]);

            const draw = () => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);

                const originX = width / 2 + offset.x;
                const originY = height / 2 + offset.y;

                const toPxX = (x) => originX + x * scale;
                const toPxY = (y) => originY - y * scale; 

                const toMathX = (px) => (px - originX) / scale;
                const toMathY = (py) => (originY - py) / scale;

                const xMin = toMathX(0);
                const xMax = toMathX(width);
                const yMin = toMathY(height); 
                const yMax = toMathY(0);
                
                const mathYMin = Math.min(yMin, yMax);
                const mathYMax = Math.max(yMin, yMax);

                drawGridAndAxes(ctx, width, height, xMin, xMax, mathYMin, mathYMax, toPxX, toPxY, originX, originY);

                if (showFeasibleOnly) {
                    ctx.save();
                    ctx.fillStyle = 'rgba(34, 197, 94, 0.4)'; 
                    ctx.fillRect(0, 0, width, height);
                    
                    ctx.globalCompositeOperation = 'destination-out';
                    
                    inequalities.forEach(ineq => {
                        if (!ineq.visible || !ineq.showRegion) return;
                        drawHalfPlane(ctx, ineq, xMin, xMax, mathYMin, mathYMax, toPxX, toPxY, true); 
                    });
                    
                    ctx.restore();

                    inequalities.forEach(ineq => {
                         if (!ineq.visible) return;
                         drawLine(ctx, ineq, xMin, xMax, mathYMin, mathYMax, toPxX, toPxY);
                    });

                } else {
                    inequalities.forEach(ineq => {
                        if (!ineq.visible) return;
                        if (ineq.showRegion) {
                            ctx.fillStyle = ineq.color + '33';
                            ctx.save();
                            drawHalfPlane(ctx, ineq, xMin, xMax, mathYMin, mathYMax, toPxX, toPxY, false);
                            ctx.restore();
                        }
                        drawLine(ctx, ineq, xMin, xMax, mathYMin, mathYMax, toPxX, toPxY);
                    });
                }
            };

            const drawGridAndAxes = (ctx, width, height, xMin, xMax, yMin, yMax, toPxX, toPxY, originX, originY) => {
                ctx.lineWidth = 1;
                ctx.strokeStyle = '#e2e8f0'; 
                ctx.fillStyle = '#64748b';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';

                let step = 1;
                if (scale < 20) step = 5;
                if (scale < 10) step = 10;
                
                const startX = Math.floor(xMin / step) * step;
                const endX = Math.ceil(xMax / step) * step;
                
                for (let x = startX; x <= endX; x += step) {
                    const px = toPxX(x);
                    ctx.beginPath();
                    ctx.moveTo(px, 0);
                    ctx.lineTo(px, height);
                    ctx.stroke();

                    if (x !== 0 && originY >= -20 && originY <= height + 20) {
                        ctx.fillText(x.toString(), px, originY + 5);
                    }
                }

                const startY = Math.floor(yMin / step) * step;
                const endY = Math.ceil(yMax / step) * step;
                
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';

                for (let y = startY; y <= endY; y += step) {
                    const py = toPxY(y);
                    ctx.beginPath();
                    ctx.moveTo(0, py);
                    ctx.lineTo(width, py);
                    ctx.stroke();

                    if (y !== 0 && originX >= -20 && originX <= width + 20) {
                        ctx.fillText(y.toString(), originX - 5, py);
                    }
                }

                ctx.lineWidth = 2;
                ctx.strokeStyle = '#475569';
                
                if (originY >= 0 && originY <= height) {
                    ctx.beginPath();
                    ctx.moveTo(0, originY);
                    ctx.lineTo(width, originY);
                    ctx.stroke();
                }

                if (originX >= 0 && originX <= width) {
                    ctx.beginPath();
                    ctx.moveTo(originX, 0);
                    ctx.lineTo(originX, height);
                    ctx.stroke();
                }
                
                if (originX >= 0 && originX <= width && originY >= 0 && originY <= height) {
                     ctx.fillStyle = '#475569';
                     ctx.fillText("0", originX - 5, originY + 5);
                }
            };

            const drawLine = (ctx, ineq, xMin, xMax, yMin, yMax, toPxX, toPxY) => {
                const { a, b, c, sign, color } = ineq;
                const pts = getIntersections(a, b, c, xMin, xMax, yMin, yMax);
                
                if (pts.length < 2) return; 

                pts.sort((p1, p2) => p1.x - p2.x);

                ctx.beginPath();
                ctx.moveTo(toPxX(pts[0].x), toPxY(pts[0].y));
                ctx.lineTo(toPxX(pts[1].x), toPxY(pts[1].y));
                
                ctx.lineWidth = 3;
                ctx.strokeStyle = color;
                if (sign === '<' || sign === '>') {
                    ctx.setLineDash([10, 10]);
                } else {
                    ctx.setLineDash([]);
                }
                ctx.stroke();
                ctx.setLineDash([]);
            };

            const drawHalfPlane = (ctx, ineq, xMin, xMax, yMin, yMax, toPxX, toPxY, drawInvalid = false) => {
                const { a, b, c } = ineq;
                const corners = [
                    { x: xMin, y: yMin },
                    { x: xMax, y: yMin },
                    { x: xMax, y: yMax },
                    { x: xMin, y: yMax }
                ];

                let intersections = getIntersections(a, b, c, xMin, xMax, yMin, yMax);
                
                if (intersections.length < 2) {
                    const cx = (xMin + xMax) / 2;
                    const cy = (yMin + yMax) / 2;
                    let satisfies = checkInequality(cx, cy, ineq);
                    if (drawInvalid) satisfies = !satisfies;

                    if (satisfies) {
                        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    }
                    return;
                }

                let polyPoints = [...intersections];
                corners.forEach(corner => {
                     let valid = checkInequality(corner.x, corner.y, ineq);
                     if (drawInvalid) valid = !valid;
                     if (valid) polyPoints.push(corner);
                });

                if (polyPoints.length < 3) return;

                const center = polyPoints.reduce((acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }), { x: 0, y: 0 });
                center.x /= polyPoints.length;
                center.y /= polyPoints.length;

                polyPoints.sort((p1, p2) => {
                    return Math.atan2(p1.y - center.y, p1.x - center.x) - Math.atan2(p2.y - center.y, p2.x - center.x);
                });

                ctx.beginPath();
                ctx.moveTo(toPxX(polyPoints[0].x), toPxY(polyPoints[0].y));
                for (let i = 1; i < polyPoints.length; i++) {
                    ctx.lineTo(toPxX(polyPoints[i].x), toPxY(polyPoints[i].y));
                }
                ctx.closePath();
                
                if (drawInvalid) ctx.fillStyle = '#000000'; 
                ctx.fill();
            };

            const handleMouseDown = (e) => {
                setIsDragging(true);
                setLastPos({ x: e.clientX, y: e.clientY });
            };
            
            const handleMouseMove = (e) => {
                if (!isDragging) return;
                const dx = e.clientX - lastPos.x;
                const dy = e.clientY - lastPos.y;
                setOffset(prev => ({ x: prev.x + dx, y: prev.y + dy }));
                setLastPos({ x: e.clientX, y: e.clientY });
            };
            
            const handleMouseUp = () => setIsDragging(false);
            
            const handleWheel = (e) => {
                e.preventDefault();
                const zoomSpeed = 0.1;
                const newScale = e.deltaY > 0 ? scale * (1 - zoomSpeed) : scale * (1 + zoomSpeed);
                if (newScale > 5 && newScale < 500) setScale(newScale);
            };

            return (
                <div 
                    ref={containerRef} 
                    className="w-full h-full cursor-move bg-white relative"
                    onMouseDown={handleMouseDown}
                    onMouseMove={handleMouseMove}
                    onMouseUp={handleMouseUp}
                    onMouseLeave={handleMouseUp}
                    onWheel={handleWheel}
                >
                    <canvas ref={canvasRef} className="absolute top-0 left-0" />
                    <div className="absolute bottom-6 right-6 flex flex-col gap-2 bg-white p-2 rounded-lg shadow-lg border border-slate-200">
                        <button onClick={() => setScale(s => Math.min(s * 1.2, 500))} className="p-2 hover:bg-slate-100 rounded text-slate-600"><Icon name="zoom-in" /></button>
                        <button onClick={() => setScale(s => Math.max(s / 1.2, 5))} className="p-2 hover:bg-slate-100 rounded text-slate-600"><Icon name="zoom-out" /></button>
                        <button onClick={() => { setOffset({x:0, y:0}); setScale(40); }} className="p-2 hover:bg-slate-100 rounded text-slate-600" title="Reset View"><Icon name="refresh-ccw" /></button>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [inequalities, setInequalities] = useState([
                { id: 1, a: 1, b: 1, c: 6, sign: '≤', color: '#3b82f6', showRegion: true, visible: true },
            ]);
            
            const [showFeasibleOnly, setShowFeasibleOnly] = useState(false);
            const [activeScenario, setActiveScenario] = useState(null);
            const [savedScenario, setSavedScenario] = useState(null);

            const addInequality = (data = null) => {
                const newId = Math.max(0, ...inequalities.map(i => i.id)) + 1;
                const defaults = data || { a: 1, b: 1, c: 5, sign: '≤' };
                
                setInequalities([
                    ...inequalities, 
                    { 
                        id: newId, 
                        ...defaults,
                        color: getRandomColor(), 
                        showRegion: true, 
                        visible: true 
                    }
                ]);
            };

            const updateInequality = (updated) => {
                setInequalities(inequalities.map(i => i.id === updated.id ? updated : i));
            };

            const removeInequality = (id) => {
                setInequalities(inequalities.filter(i => i.id !== id));
            };

            const generateRandomScenario = () => {
                const random = SCENARIOS[Math.floor(Math.random() * SCENARIOS.length)];
                setActiveScenario(random);
            };

            const loadScenarioEquations = (eqs) => {
                const newEqs = eqs.map((eq, idx) => ({
                    id: idx + 1,
                    ...eq,
                    color: getRandomColor(),
                    showRegion: true,
                    visible: true
                }));
                setInequalities(newEqs);
                setActiveScenario(null); 
                setSavedScenario(null); // Clear saved if loaded
                setShowFeasibleOnly(true);
            };

            const saveScenarioForLater = (scenario) => {
                setSavedScenario(scenario);
                setActiveScenario(null);
            };

            return (
                <div className="flex h-screen w-full flex-col md:flex-row relative">
                    <ScenarioModal 
                        scenario={activeScenario} 
                        onClose={() => setActiveScenario(null)} 
                        onLoadEquations={loadScenarioEquations}
                        onSave={saveScenarioForLater}
                    />

                    {/* Sidebar */}
                    <div className="w-full md:w-96 bg-slate-50 border-r border-slate-200 flex flex-col shadow-xl z-10 h-full">
                        <div className="p-4 bg-white border-b border-slate-200">
                            <h1 className="text-xl font-bold text-slate-800 flex items-center gap-2">
                                <Icon name="drafting-compass" className="text-blue-600" />
                                LP Explorer
                            </h1>
                            <p className="text-sm text-slate-500 mt-1">Grade 11 Mathematics Tool</p>
                        </div>

                        <div className="flex-1 overflow-y-auto p-4">
                            {/* Actions Section */}
                            <div className="mb-6 flex flex-col gap-2">
                                <h2 className="text-xs font-bold text-slate-400 uppercase tracking-wider mb-1">Actions</h2>
                                
                                {savedScenario && (
                                    <button 
                                        onClick={() => setActiveScenario(savedScenario)}
                                        className="w-full mb-2 bg-emerald-50 border border-emerald-200 p-3 rounded-lg flex items-center gap-3 hover:bg-emerald-100 transition-colors group text-left"
                                    >
                                        <div className="bg-emerald-500 text-white p-2 rounded-lg group-hover:scale-105 transition-transform">
                                            <Icon name="play" size={16} fill="currentColor" />
                                        </div>
                                        <div>
                                            <span className="text-xs font-bold text-emerald-600 uppercase tracking-wider block">Resume Scenario</span>
                                            <span className="text-sm font-bold text-slate-700">{savedScenario.title}</span>
                                        </div>
                                    </button>
                                )}

                                <button 
                                    onClick={generateRandomScenario}
                                    className="w-full flex items-center justify-center gap-2 bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 text-white py-3 px-4 rounded-lg shadow-sm transition-all text-sm font-semibold"
                                >
                                    <Icon name="book-open" size={18} />
                                    Generate Scenario
                                </button>
                                
                                <button 
                                    onClick={() => addInequality()}
                                    className="w-full flex items-center justify-center gap-2 border border-slate-300 bg-white hover:bg-slate-50 text-slate-700 py-2.5 px-4 rounded-lg transition-all text-sm font-medium"
                                >
                                    <Icon name="plus" size={16} />
                                    Add Custom Equation
                                </button>
                            </div>

                            <div className="flex justify-between items-center mb-2">
                                <h2 className="text-xs font-bold text-slate-400 uppercase tracking-wider">Active Equations</h2>
                                <span className="text-xs text-slate-400 bg-slate-100 px-2 py-0.5 rounded-full">{inequalities.length}</span>
                            </div>

                            <div className="space-y-2 pb-4">
                                {inequalities.map(ineq => (
                                    <InequalityRow 
                                        key={ineq.id} 
                                        ineq={ineq} 
                                        onChange={updateInequality} 
                                        onRemove={() => removeInequality(ineq.id)}
                                    />
                                ))}
                            </div>
                            
                            {inequalities.length === 0 && (
                                <div className="text-center py-8 text-slate-400 border-2 border-dashed border-slate-200 rounded-lg">
                                    <p>No equations added.</p>
                                    <p className="text-xs mt-1">Generate a scenario to start.</p>
                                </div>
                            )}
                        </div>

                        <div className="p-4 bg-white border-t border-slate-200">
                            <div className="flex flex-col gap-3">
                                <label className="flex items-center justify-between p-3 rounded-lg border border-slate-200 cursor-pointer hover:bg-slate-50 transition-colors">
                                    <div className="flex flex-col">
                                        <span className="font-semibold text-slate-700 text-sm">Feasible Region Only</span>
                                        <span className="text-xs text-slate-500">Highlight valid intersection</span>
                                    </div>
                                    <div className={`w-12 h-6 rounded-full p-1 transition-colors ${showFeasibleOnly ? 'bg-green-500' : 'bg-slate-300'}`}>
                                        <div className={`bg-white w-4 h-4 rounded-full shadow-sm transform transition-transform ${showFeasibleOnly ? 'translate-x-6' : ''}`}></div>
                                    </div>
                                    <input 
                                        type="checkbox" 
                                        checked={showFeasibleOnly}
                                        onChange={(e) => setShowFeasibleOnly(e.target.checked)}
                                        className="hidden"
                                    />
                                </label>
                            </div>
                        </div>
                    </div>

                    {/* Main Canvas Area */}
                    <div className="flex-1 relative bg-gray-50 overflow-hidden">
                        <CanvasGraph inequalities={inequalities} showFeasibleOnly={showFeasibleOnly} />
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
